# DevLog-002-03: Via Layer Parsing Bug

**Date:** 2025-12-15
**Status:** Fixed
**Severity:** High

## Summary

Via layers (40, 43, 44) in `ring_modulator_pin.gds` are rendering at position (0,0) instead of their correct transformed positions through the cell hierarchy. Root cause identified: Parser is only reading 4 out of 7 cell instances from the `via_stack` cell, missing the 3 via cell references.

## Bug Description

**Observed Behavior:**
- Via cells on layers 40, 43, 44 render at origin (0,0)
- Expected to appear at transformed positions through hierarchy

**Expected Behavior:**
- Via cells should be referenced by `via_stack` at position (-13.0, -3.0)
- `via_stack` referenced by `straight_pin` at (15.0, ±6.5)
- `straight_pin` referenced by `ring_single_pin` at (-10.0, 22.7)
- Final via positions should reflect full transformation chain

## Root Cause Analysis

### Investigation Steps

1. **Verified GDS file structure using gdstk:**
   ```
   via_stack has 7 references:
     0-3: compass cells at (0.0, 0.0)
     4-6: via cells at (-13.0, -3.0)
   ```

2. **Checked parser output:**
   - Parser only reads 4 instances from `via_stack` (compass cells)
   - Missing 3 via cell instances (indices 4-6)
   - Via cells incorrectly classified as top cells
   - Top cells render at (0,0) by design

3. **Confirmed rendering logic:**
   - Top cells rendered at position (0,0) in `GDSRenderer.ts:118-125`
   - Via cells classified as top cells because they're not in `referencedCells` set
   - Not in `referencedCells` because `via_stack` doesn't have them in its instances array

### Root Cause

**Parser bug in `GDSParser.ts`:** The SREF/SNAME/ENDEL parsing logic is failing to parse instances 4-6 from the `via_stack` cell. The via cell instances exist in the GDS file but are not being added to the cell's instances array during parsing.

**Why via cells are classified as top cells:**
1. Top cell detection logic (line 1167-1176) builds `referencedCells` set by iterating through all `cell.instances`
2. `via_stack.instances` only contains 4 instances (compass cells), missing the 3 via instances
3. Via cell names never get added to `referencedCells` set
4. Any cell not in `referencedCells` is classified as a top cell
5. Top cells are rendered at position (0,0) by `GDSRenderer.ts:118-125`

The top cell classification is a symptom, not the root cause. The root cause is the parser failing to populate `via_stack.instances` with all 7 references.

## Debug Logging Added

### GDSParser.ts

1. **Line 1022-1032:** Log SNAME records for via_stack instances
2. **Line 1001-1013:** Log instances being added to via_stack at ENDEL
3. **Line 1169-1172:** Log via cell reference status in top cell detection

### GDSRenderer.ts

1. **Line 360-367:** Log instance transformation calculations (first 3 instances per cell)

## Test File

**Location:** `tests/gds/ring_modulator_pin.gds`  
**Source:** `/Users/wentaojiang/Documents/GitHub/PlayGround/20251129_gdsfactory/ring_modulator_pin.gds`  
**Analysis:** `tests/gds/ring_modulator_pin.log` (generated by `read_gds.py`)

**File Structure:**
- 16 cells total
- Via cells: `via_gdsfactorypcomponentspviaspvia_S0p7_0p7_E1_LVIAC_BL_572539c8` (layer 40)
- Via cells: `via_gdsfactorypcomponentspviaspvia_S0p7_0p7_E1_LVIA1_BL_0068d91e` (layer 44)
- Via cells: `via_gdsfactorypcomponentspviaspvia_S0p7_0p7_E1_LVIA2_BL_c51b5ebb` (layer 43)

## Console Output Evidence

```
[GDSParser] Cell "via_stack_..." references "compass_..." (4 times only)
[GDSParser] Via cell "...LVIA2...": referenced=false, isTopCell=true
[GDSParser] Via cell "...LVIA1...": referenced=false, isTopCell=true
[GDSParser] Via cell "...LVIAC...": referenced=false, isTopCell=true
```

Expected: 7 references (4 compass + 3 via)  
Actual: 4 references (4 compass only)

## Root Cause Analysis

### Initial Hypothesis (INCORRECT)

Initially suspected the XY record handler's `if-else if` chain was not mutually exclusive, causing XY records for instances to be consumed by polygon/path handlers.

### Actual Root Cause (CORRECT)

**The parser had NO support for AREF (array reference) records.**

When the parser encountered AREF records, it didn't create a `currentInstance`, so when the XY record arrived, `currentInstance` was null and the XY data was skipped.

### Discovery Process

1. **Added debug logging** to trace record sequence in `via_stack` cell
2. **Found the pattern**:
   ```
   AREF
   SNAME
   COLROW
   XY
   ENDEL
   ```
3. **Key insight**: The missing instances were AREF (array references), not SREF (single references)
4. **Verified with gdstk**: Each via reference has 14 columns × 4 rows = 56 instances

### AREF Format Understanding

**AREF record structure:**
- `AREF`: Start array reference
- `SNAME`: Cell name to reference
- `COLROW`: Array dimensions (columns, rows)
- `XY`: 3 points defining the array:
  1. **Origin**: Base position of first instance
  2. **Column end**: origin + column_vector × columns
  3. **Row end**: origin + row_vector × rows
- `ENDEL`: End array reference

**Example from ring_modulator_pin.gds:**
- Origin: (-13.0, -3.0)
- Column end: (15.0, -3.0) → column_vector = (28.0, 0) for 14 columns → spacing = 2.0 µm in X
- Row end: (-13.0, 5.0) → row_vector = (0, 8.0) for 4 rows → spacing = 2.0 µm in Y

## Fix Implementation

### Changes Made

**File:** `src/lib/gds/GDSParser.ts`

#### 1. Added AREF handler (line 1047-1062)

```typescript
case RecordType.SREF: // Structure reference (instance)
case RecordType.AREF: // Array reference (will be expanded to multiple instances)
    currentInstance = {
        id: generateUUID(),
        cellRef: "",
        x: 0,
        y: 0,
        rotation: 0,
        mirror: false,
        magnification: 1.0,
        boundingBox: { minX: 0, minY: 0, maxX: 0, maxY: 0 },
    };
    break;
```

#### 2. Added COLROW handler (line 1066-1071)

```typescript
case RecordType.COLROW: // Array dimensions (for AREF)
    if (currentInstance && typeof data === "object" && data !== null) {
        currentInstance.arrayCols = (data as { columns: number; rows: number }).columns;
        currentInstance.arrayRows = (data as { columns: number; rows: number }).rows;
    }
    break;
```

#### 3. Updated XY handler for AREF (line 875-894)

```typescript
// For AREF, store spacing vectors (total displacement, will be divided by count later)
if (data.length >= 3) {
    currentInstance.arraySpacingX = data[1][0] - data[0][0];
    currentInstance.arraySpacingY = data[2][1] - data[0][1];
}
```

#### 4. Expanded AREF into instances at ENDEL (line 1013-1051)

```typescript
// Check if this is an AREF (array reference) that needs expansion
if (currentInstance.arrayCols && currentInstance.arrayRows) {
    const cols = currentInstance.arrayCols;
    const rows = currentInstance.arrayRows;

    // AREF XY contains: [origin, col_end, row_end]
    // col_spacing = (col_end - origin) / cols
    // row_spacing = (row_end - origin) / rows
    const colSpacingX = (currentInstance.arraySpacingX || 0) / cols;
    const rowSpacingY = (currentInstance.arraySpacingY || 0) / rows;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const instance: CellInstance = {
                id: generateUUID(),
                cellRef: currentInstance.cellRef,
                x: baseX + col * colSpacingX,
                y: baseY + row * rowSpacingY,
                rotation: rotation,
                mirror: mirror,
                magnification: magnification,
                boundingBox: { minX: 0, minY: 0, maxX: 0, maxY: 0 },
            };
            currentCell.instances.push(instance);
            instanceCount++;
        }
    }
}
```

### Key Learning: AREF Coordinate Transformation

**CRITICAL**: The XY record for AREF contains **total displacement**, not per-instance spacing:
- `arraySpacingX = col_end.x - origin.x` (total displacement for all columns)
- `arraySpacingY = row_end.y - origin.y` (total displacement for all rows)

**Per-instance spacing** must be calculated by dividing by count:
- `colSpacingX = arraySpacingX / cols`
- `rowSpacingY = arraySpacingY / rows`

**Example:**
- XY data: origin=(-13000, -3000), col_end=(15000, -3000), row_end=(-13000, 5000)
- Total displacement: X=28000, Y=8000
- Array dimensions: 14 cols × 4 rows
- Per-instance spacing: X=2000 (2.0 µm), Y=2000 (2.0 µm)

### Verification

After fix:
- All 7 references in `via_stack` cell are parsed (4 compass + 3 via arrays)
- Each via array expands to 56 instances (14 × 4)
- Via cells are correctly classified as referenced cells (not top cells)
- Via instances render at correct positions with 2.0 µm spacing

## Related Files

- `src/lib/gds/GDSParser.ts` - Parser (fixed)
- `src/lib/renderer/rendering/GDSRenderer.ts` - Renderer (working correctly)
- `tests/gds/ring_modulator_pin.gds` - Test file
- `tests/gds/ring_modulator_pin.log` - GDS structure analysis

